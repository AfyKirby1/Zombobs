<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Zombie Survival</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Roboto+Mono:wght@400;700&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000000;
            font-family: 'Roboto Mono', monospace;
            color: #fff;
            overflow: hidden;
        }
        #gameContainer {
            text-align: center;
            position: relative;
        }
        canvas {
            display: block;
            margin: 0 auto;
            cursor: none; /* Hide system cursor so custom crosshair takes precedence */
        }






    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Render scale: internal canvas resolution vs on-screen size
        // Lower than 1.0 = better performance, slightly softer visuals
        const RENDER_SCALE = 0.75;

        // Declare player variable first (will be initialized after canvas resize)
        let player;

        // Function to resize canvas to fit window
        function resizeCanvas() {
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;

            // Internal canvas resolution (scaled down for performance)
            canvas.width = Math.floor(displayWidth * RENDER_SCALE);
            canvas.height = Math.floor(displayHeight * RENDER_SCALE);

            // Visual size still fills the window
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            // Update player position to center if player exists
            if (player) {
                player.x = canvas.width / 2;
                player.y = canvas.height / 2;
                
                // Keep player within bounds
                player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
                player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
            }
        }

        // Initial resize - sets canvas size before player initialization
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        let gameRunning = true;
        let gamePaused = false; // Pause state
        let showMainMenu = true; // Main menu state
        let score = 0;
        let wave = 1;
        let zombiesKilled = 0;
        let zombiesPerWave = 5;
        let highScore = 0; // High score tracking
        let isSpawningWave = false; // Prevent multiple wave increments

        // Player stats
        const PLAYER_MAX_HEALTH = 100;

        // Health pickup settings (simple first iteration)
        const HEALTH_PICKUP_HEAL_AMOUNT = 25;
        const HEALTH_PICKUP_SPAWN_INTERVAL = 15000; // ms between spawns
        const MAX_HEALTH_PICKUPS = 3;
        
        // Ammo pickup settings
        const AMMO_PICKUP_AMOUNT = 15; // Ammo restored per pickup
        const AMMO_PICKUP_SPAWN_INTERVAL = 20000; // ms between spawns (20 seconds)
        const MAX_AMMO_PICKUPS = 2;

        // FPS counter state
        let fps = 0;
        let lastFpsUpdateTime = performance.now();
        let framesSinceFpsUpdate = 0;
        
        // Weapon system
        const weapons = {
            pistol: {
                name: "Pistol",
                damage: 1,
                fireRate: 400, // ms between shots
                ammo: 10,
                maxAmmo: 10,
                reloadTime: 1000 // ms (1 second)
            },
            shotgun: {
                name: "Shotgun",
                damage: 3,
                fireRate: 800, // ms between shots
                ammo: 5,
                maxAmmo: 5,
                reloadTime: 1000 // ms (1 second)
            },
            rifle: {
                name: "Rifle",
                damage: 2,
                fireRate: 200, // ms between shots
                ammo: 30,
                maxAmmo: 30,
                reloadTime: 1000 // ms (1 second)
            }
        };
        
        let currentWeapon = weapons.pistol;
        let lastShotTime = 0;
        let isReloading = false;
        let reloadStartTime = 0;
        
        // Ammo state (now weapon-specific)
        let currentAmmo = currentWeapon.ammo;
        let maxAmmo = currentWeapon.maxAmmo;
        
        // Low ammo threshold (25% of max ammo)
        const LOW_AMMO_FRACTION = 0.25;

        // Initialize player (after canvas resize)
        player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 15,
            speed: 4,
            health: PLAYER_MAX_HEALTH,
            angle: 0
        };

        // Walking sound timing
        let lastFootstepTime = 0;
        const footstepInterval = 350; // Play footstep every 350ms when moving (in milliseconds)

        // Input
        const keys = {};
        const mouse = { x: 0, y: 0, isDown: false };
        
        // Crosshair configuration
        const crosshairSize = 12;
        const crosshairLineWidth = 2;
        const crosshairColor = '#ffffff';
        const crosshairOutlineColor = '#000000';

        // Game objects
        let bullets = [];
        let zombies = [];
        let particles = [];
        let healthPickups = [];
        let ammoPickups = [];
        let zombieSpawnTimeouts = []; // Track pending zombie spawn timeouts
        let shells = [];
        let damageNumbers = [];
        let grenades = [];
        
        // Grenade system
        const MAX_GRENADES = 3; // Maximum grenades player can carry
        let grenadeCount = MAX_GRENADES; // Start with max grenades
        let lastGrenadeThrowTime = 0;
        const GRENADE_COOLDOWN = 2000; // 2 seconds between throws
        const GRENADE_EXPLOSION_RADIUS = 80; // AOE damage radius
        const GRENADE_DAMAGE = 50; // High damage for AOE
        const GRENADE_FUSE_TIME = 1500; // 1.5 seconds before explosion
        
        // Screen shake
        let shakeAmount = 0;
        let shakeDecay = 0.9;
        
        // Damage indicators
        let damageIndicator = {
            active: false,
            intensity: 0,
            decay: 0.95
        };

        // Wave start notification
        let waveNotification = {
            active: false,
            text: '',
            life: 0,
            maxLife: 120 // ~2 seconds at 60fps
        };

        // Muzzle flash
        let muzzleFlash = {
            active: false,
            intensity: 0,
            x: 0,
            y: 0,
            angle: 0,
            life: 0,
            maxLife: 5
        };

        // HUD Component
        class GameHUD {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.padding = 15;
                this.itemSpacing = 12;
                this.fontSize = 16;
                this.font = `700 ${this.fontSize}px 'Roboto Mono', monospace`;
                this.gameOver = false;
                this.paused = false;
                this.finalScore = '';
                this.mainMenu = false;
                this.hoveredButton = null; // Track which button is hovered
            }

            drawStat(label, value, icon, color, x, y, width) {
                // Background with glow
                const bgGradient = this.ctx.createLinearGradient(x, y, x, y + 40);
                bgGradient.addColorStop(0, 'rgba(42, 42, 42, 0.85)');
                bgGradient.addColorStop(1, 'rgba(26, 26, 26, 0.85)');
                
                // Main background
                this.ctx.fillStyle = bgGradient;
                this.ctx.fillRect(x, y, width, 40);
                
                // Border
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(x, y, width, 40);
                
                // Glow effect
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = color;
                this.ctx.strokeRect(x, y, width, 40);
                this.ctx.shadowBlur = 0;
                
                // Text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = this.font;
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'middle';
                
                // Icon and label
                const text = `${icon} ${label}:`;
                this.ctx.fillText(text, x + 10, y + 13);
                
                // Value
                this.ctx.fillStyle = color;
                this.ctx.font = `700 ${this.fontSize + 2}px 'Roboto Mono', monospace`;
                this.ctx.fillText(value, x + 10, y + 27);
            }

            draw() {
                // Draw main menu if active
                if (this.mainMenu) {
                    this.drawMainMenu();
                    return;
                }
                
                // Draw regular HUD elements if game is running
                if (!this.gameOver && !this.paused) {
                    const startX = this.padding;
                    let startY = this.padding;
                    
                    // Health (redder when low)
                    const healthValue = Math.max(0, Math.floor(player.health));
                    const healthColor = player.health < 30 ? '#ff0000' : '#ff1744';
                    this.drawStat('Health', healthValue, 'â¤ï¸', healthColor, startX, startY, 140);
                    startY += 40 + this.itemSpacing;
                    
                    // Weapon and Ammo
                    let ammoColor;
                    if (isReloading) {
                        ammoColor = '#ff9800'; // Keep existing reload color
                    } else if (currentAmmo === 0) {
                        ammoColor = '#ff5722'; // Empty ammo color
                    } else if (currentAmmo <= maxAmmo * LOW_AMMO_FRACTION) {
                        // Low ammo warning - bright red with optional pulse effect
                        const t = Date.now() / 200;
                        const pulse = 0.5 + 0.5 * Math.sin(t);
                        const lowColor1 = '#ff0000';
                        const lowColor2 = '#ff4444';
                        // Blend between two colors for pulse effect
                        const r1 = parseInt(lowColor1.slice(1, 3), 16);
                        const g1 = parseInt(lowColor1.slice(3, 5), 16);
                        const b1 = parseInt(lowColor1.slice(5, 7), 16);
                        const r2 = parseInt(lowColor2.slice(1, 3), 16);
                        const g2 = parseInt(lowColor2.slice(3, 5), 16);
                        const b2 = parseInt(lowColor2.slice(5, 7), 16);
                        const r = Math.floor(r1 + (r2 - r1) * pulse);
                        const g = Math.floor(g1 + (g2 - g1) * pulse);
                        const b = Math.floor(b1 + (b2 - b1) * pulse);
                        ammoColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                    } else {
                        ammoColor = '#ff9800'; // Normal ammo color
                    }
                    const ammoText = isReloading ? `Reloading...` : `${currentAmmo}/${maxAmmo}`;
                    this.drawStat(currentWeapon.name, ammoText, 'ðŸ”«', ammoColor, startX, startY, 140);
                    startY += 40 + this.itemSpacing;
                    
                    // Kills
                    this.drawStat('Kills', zombiesKilled, 'ðŸ’€', '#76ff03', startX, startY, 140);
                    startY += 40 + this.itemSpacing;
                    
                    // Wave
                    this.drawStat('Wave', wave, 'ðŸŒŠ', '#ffc107', startX, startY, 140);
                    startY += 40 + this.itemSpacing;
                    
                    // High Score
                    this.drawStat('High Score', highScore, 'ðŸ†', '#ffd700', startX, startY, 140);
                    startY += 40 + this.itemSpacing;
                    
                    // Grenades
                    const grenadeColor = grenadeCount > 0 ? '#ff9800' : '#666666';
                    this.drawStat('Grenades', grenadeCount, 'ðŸ’£', grenadeColor, startX, startY, 140);
                    
                    // Draw instructions at the bottom of the canvas
                    this.ctx.fillStyle = 'rgba(153, 153, 153, 0.7)';
                    this.ctx.font = '14px "Roboto Mono", monospace';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('WASD to move â€¢ Mouse to aim â€¢ Click to shoot â€¢ 1/2/3 to switch weapons â€¢ G for grenade', this.canvas.width / 2, this.canvas.height - 20);
                }
                
                // Draw game over screen
                if (this.gameOver) {
                    this.drawGameOver();
                }
                
                // Draw pause screen
                if (this.paused) {
                    this.drawPauseMenu();
                }
            }

            drawGameOver() {
                // Semi-transparent overlay
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Game over title
                this.ctx.font = '48px "Creepster", cursive';
                this.ctx.textAlign = 'center';
                this.ctx.fillStyle = '#ff0000';
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 100);
                this.ctx.shadowBlur = 0;
                
                // Final score text
                this.ctx.font = '20px "Roboto Mono", monospace';
                this.ctx.fillStyle = '#cccccc';
                this.ctx.textAlign = 'center';
                const lines = this.finalScore.split('\n');
                lines.forEach((line, index) => {
                    this.ctx.fillText(line, this.canvas.width / 2, this.canvas.height / 2 - 30 + (index * 30));
                });
                
                // Restart instruction
                this.ctx.fillStyle = '#ff0000';
                this.ctx.font = '16px "Roboto Mono", monospace';
                this.ctx.fillText('Press R to Restart', this.canvas.width / 2, this.canvas.height / 2 + 50);
            }

            drawPauseMenu() {
                // Semi-transparent overlay
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Pause title
                this.ctx.font = '48px "Creepster", cursive';
                this.ctx.textAlign = 'center';
                this.ctx.fillStyle = '#ff0000';
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2 - 80);
                this.ctx.shadowBlur = 0;
                
                // Pause instruction
                this.ctx.font = '20px "Roboto Mono", monospace';
                this.ctx.fillStyle = '#cccccc';
                this.ctx.fillText('Game is currently paused', this.canvas.width / 2, this.canvas.height / 2 - 20);
                
                // Controls instruction
                this.ctx.fillStyle = '#ff0000';
                this.ctx.font = '16px "Roboto Mono", monospace';
                this.ctx.fillText('Press ESC to Resume', this.canvas.width / 2, this.canvas.height / 2 + 40);
                this.ctx.fillText('Press R to Restart', this.canvas.width / 2, this.canvas.height / 2 + 70);
                this.ctx.fillText('Press M to Return to Menu', this.canvas.width / 2, this.canvas.height / 2 + 100);
            }

            showGameOver(scoreText) {
                this.gameOver = true;
                this.finalScore = scoreText;
            }

            showPauseMenu() {
                this.paused = true;
            }

            hidePauseMenu() {
                this.paused = false;
            }

            hideGameOver() {
                this.gameOver = false;
                this.finalScore = '';
            }

            drawMainMenu() {
                // Dark overlay background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Title
                this.ctx.font = 'bold 64px "Creepster", cursive';
                this.ctx.textAlign = 'center';
                this.ctx.fillStyle = '#ff1744';
                this.ctx.shadowBlur = 30;
                this.ctx.shadowColor = 'rgba(255, 23, 68, 0.8)';
                this.ctx.fillText('ZOMBOBS', this.canvas.width / 2, this.canvas.height / 2 - 180);
                this.ctx.shadowBlur = 0;
                
                // Subtitle
                this.ctx.font = '18px "Roboto Mono", monospace';
                this.ctx.fillStyle = '#9e9e9e';
                this.ctx.fillText('Survive the Horde', this.canvas.width / 2, this.canvas.height / 2 - 130);
                
                // Button dimensions and positions
                const buttonWidth = 280;
                const buttonHeight = 60;
                const buttonSpacing = 20;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                const singlePlayerY = centerY - (buttonHeight + buttonSpacing);
                const settingsY = centerY;
                const multiplayerY = centerY + buttonHeight + buttonSpacing;

                // Single Player Button
                const singlePlayerHovered = this.hoveredButton === 'single';
                this.drawMenuButton(
                    'Single Player',
                    centerX - buttonWidth / 2,
                    singlePlayerY - buttonHeight / 2,
                    buttonWidth,
                    buttonHeight,
                    singlePlayerHovered,
                    false
                );

                // Settings Button (disabled)
                const settingsHovered = this.hoveredButton === 'settings';
                this.drawMenuButton(
                    'Settings',
                    centerX - buttonWidth / 2,
                    settingsY - buttonHeight / 2,
                    buttonWidth,
                    buttonHeight,
                    settingsHovered,
                    true // disabled
                );
                
                // Multiplayer Button (disabled)
                const multiplayerHovered = this.hoveredButton === 'multiplayer';
                this.drawMenuButton(
                    'Multiplayer',
                    centerX - buttonWidth / 2,
                    multiplayerY - buttonHeight / 2,
                    buttonWidth,
                    buttonHeight,
                    multiplayerHovered,
                    true // disabled
                );
                
                // Coming Soon text
                if (multiplayerHovered || settingsHovered) {
                    this.ctx.font = '14px "Roboto Mono", monospace';
                    this.ctx.fillStyle = '#ff9800';
                    const yPos = multiplayerHovered ? multiplayerY + 50 : settingsY + 50;
                    this.ctx.fillText('Coming Soon', centerX, yPos);
                }
                
                // Footer text
                this.ctx.font = '12px "Roboto Mono", monospace';
                this.ctx.fillStyle = 'rgba(158, 158, 158, 0.6)';
                this.ctx.fillText('High Score: ' + highScore, centerX, this.canvas.height - 40);
            }

            drawMenuButton(text, x, y, width, height, hovered, disabled) {
                const alpha = disabled ? 0.5 : 1.0;
                const bgColor = disabled ? '#333333' : (hovered ? '#ff1744' : '#1a1a1a');
                const borderColor = disabled ? '#666666' : (hovered ? '#ff5252' : '#ff1744');
                const textColor = disabled ? '#888888' : '#ffffff';
                
                // Button background
                const bgGradient = this.ctx.createLinearGradient(x, y, x, y + height);
                bgGradient.addColorStop(0, disabled ? 'rgba(51, 51, 51, 0.9)' : (hovered ? 'rgba(255, 23, 68, 0.3)' : 'rgba(26, 26, 26, 0.9)'));
                bgGradient.addColorStop(1, disabled ? 'rgba(26, 26, 26, 0.9)' : (hovered ? 'rgba(255, 23, 68, 0.2)' : 'rgba(10, 10, 10, 0.9)'));
                
                this.ctx.fillStyle = bgGradient;
                this.ctx.fillRect(x, y, width, height);
                
                // Button border
                this.ctx.strokeStyle = borderColor;
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(x, y, width, height);
                
                // Glow effect (only if not disabled and hovered)
                if (!disabled && hovered) {
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = 'rgba(255, 23, 68, 0.6)';
                    this.ctx.strokeRect(x, y, width, height);
                    this.ctx.shadowBlur = 0;
                }
                
                // Button text
                this.ctx.fillStyle = textColor;
                this.ctx.font = 'bold 20px "Roboto Mono", monospace';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(text, x + width / 2, y + height / 2);
            }

            checkMenuButtonClick(mouseX, mouseY) {
                if (!this.mainMenu) return null;
                
                const buttonWidth = 280;
                const buttonHeight = 60;
                const buttonSpacing = 20;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                const singlePlayerY = centerY - (buttonHeight + buttonSpacing);
                const settingsY = centerY;
                const multiplayerY = centerY + buttonHeight + buttonSpacing;
                
                // Check Single Player button
                const singlePlayerX = centerX - buttonWidth / 2;
                const singlePlayerYTop = singlePlayerY - buttonHeight / 2;
                if (mouseX >= singlePlayerX && mouseX <= singlePlayerX + buttonWidth &&
                    mouseY >= singlePlayerYTop && mouseY <= singlePlayerYTop + buttonHeight) {
                    return 'single';
                }

                // Check Settings button
                const settingsX = centerX - buttonWidth / 2;
                const settingsYTop = settingsY - buttonHeight / 2;
                if (mouseX >= settingsX && mouseX <= settingsX + buttonWidth &&
                    mouseY >= settingsYTop && mouseY <= settingsYTop + buttonHeight) {
                    return 'settings';
                }
                
                // Check Multiplayer button
                const multiplayerX = centerX - buttonWidth / 2;
                const multiplayerYTop = multiplayerY - buttonHeight / 2;
                if (mouseX >= multiplayerX && mouseX <= multiplayerX + buttonWidth &&
                    mouseY >= multiplayerYTop && mouseY <= multiplayerYTop + buttonHeight) {
                    return 'multiplayer';
                }
                
                return null;
            }

            updateMenuHover(mouseX, mouseY) {
                if (!this.mainMenu) {
                    this.hoveredButton = null;
                    return;
                }
                this.hoveredButton = this.checkMenuButtonClick(mouseX, mouseY);
            }

            showMainMenu() {
                this.mainMenu = true;
            }

            hideMainMenu() {
                this.mainMenu = false;
                this.hoveredButton = null;
            }
        }

        // Initialize HUD
        const gameHUD = new GameHUD(canvas);

        // Grass ground pattern cache
        let grassPattern = null;

        // Function to create a tileable grass pattern
        function createGrassPattern() {
            const tileSize = 64;
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = tileSize;
            patternCanvas.height = tileSize;
            const patternCtx = patternCanvas.getContext('2d');
            
            // Base dark green grass color
            patternCtx.fillStyle = '#1a2e1a';
            patternCtx.fillRect(0, 0, tileSize, tileSize);
            
            // Add patches of slightly lighter grass
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * tileSize;
                const y = Math.random() * tileSize;
                const size = Math.random() * 8 + 3;
                const greenValue = 30 + Math.random() * 20;
                patternCtx.fillStyle = `rgba(30, ${greenValue}, 30, 0.4)`;
                patternCtx.beginPath();
                patternCtx.arc(x, y, size, 0, Math.PI * 2);
                patternCtx.fill();
            }
            
            // Add some darker spots for texture variation
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * tileSize;
                const y = Math.random() * tileSize;
                const size = Math.random() * 5 + 2;
                patternCtx.fillStyle = 'rgba(10, 20, 10, 0.6)';
                patternCtx.beginPath();
                patternCtx.arc(x, y, size, 0, Math.PI * 2);
                patternCtx.fill();
            }
            
            // Add subtle grass blades effect (small vertical lines)
            patternCtx.strokeStyle = 'rgba(20, 40, 20, 0.3)';
            patternCtx.lineWidth = 1;
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * tileSize;
                const y = Math.random() * tileSize;
                const height = Math.random() * 4 + 2;
                patternCtx.beginPath();
                patternCtx.moveTo(x, y);
                patternCtx.lineTo(x + (Math.random() - 0.5) * 2, y - height);
                patternCtx.stroke();
            }
            
            return ctx.createPattern(patternCanvas, 'repeat');
        }

        // Initialize grass pattern
        function initGrassPattern() {
            grassPattern = createGrassPattern();
        }

        // Audio Context for sound effects
        let audioContext = null;
        let gunshotBuffer = null; // Cache gunshot audio buffer so we don't regenerate it every shot
        
        // Initialize audio context (needs user interaction first)
        function initAudio() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // Pre-create the gunshot buffer once for performance
                    createGunshotBuffer();
                } catch (error) {
                    console.log('Audio context not supported:', error);
                }
            }
        }
        
        // Create and cache the gunshot sound buffer (called once)
        function createGunshotBuffer() {
            if (!audioContext || gunshotBuffer) return;
            
            const duration = 0.1; // 100ms
            const sampleRate = audioContext.sampleRate;
            const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
            const data = buffer.getChannelData(0);
            
            // Generate gunshot waveform (sharp attack + decay)
            for (let i = 0; i < buffer.length; i++) {
                const t = i / sampleRate;
                // Initial sharp crack (high frequency noise)
                let sample = Math.random() * 2 - 1;
                // Add low frequency boom
                sample += Math.sin(t * 60) * 0.5;
                // Quick decay envelope
                const envelope = Math.max(0, 1 - (t / duration) * 3);
                data[i] = sample * envelope * 0.3; // Volume
            }
            
            gunshotBuffer = buffer;
        }
        
        // Play cached gunshot sound using Web Audio API
        function playGunshotSound() {
            if (!audioContext) {
                initAudio();
                if (!audioContext) return; // Still can't create, skip sound
            }
            
            // Ensure buffer exists (in case audioContext was created elsewhere)
            if (!gunshotBuffer) {
                createGunshotBuffer();
                if (!gunshotBuffer) return;
            }
            
            try {
                const source = audioContext.createBufferSource();
                source.buffer = gunshotBuffer;
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0.4; // Volume level
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(0);
            } catch (error) {
                // Silently fail if audio can't play (e.g., browser restrictions)
            }
        }

        // Generate damage/hurt sound using Web Audio API
        function playDamageSound() {
            if (!audioContext) {
                initAudio();
                if (!audioContext) return; // Still can't create, skip sound
            }
            
            try {
                // Create a damage sound (grunt/impact like)
                const duration = 0.2; // 200ms
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);
                
                // Generate damage waveform (grunt-like with impact)
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / sampleRate;
                    // Low frequency grunt/hurt sound (vowel-like)
                    let sample = 0;
                    // Fundamental frequency (human-like grunt around 150-200Hz)
                    sample += Math.sin(t * 175 * 2 * Math.PI) * 0.6;
                    // Add harmonics for more body
                    sample += Math.sin(t * 175 * 4 * Math.PI) * 0.3;
                    sample += Math.sin(t * 175 * 6 * Math.PI) * 0.1;
                    // Add slight noise for impact texture
                    sample += (Math.random() * 2 - 1) * 0.2;
                    // Envelope: quick attack, slower decay (like a grunt)
                    const attack = Math.min(1, t / 0.02); // 20ms attack
                    const decay = Math.max(0, 1 - (t - 0.02) / (duration - 0.02));
                    const envelope = attack * decay;
                    data[i] = sample * envelope * 0.25; // Volume
                }
                
                // Play the sound
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0.375; // Volume level (reduced by 25%)
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(0);
            } catch (error) {
                // Silently fail if audio can't play
            }
        }

        // Generate walking/footstep sound using Web Audio API
        function playFootstepSound() {
            if (!audioContext) {
                initAudio();
                if (!audioContext) return; // Still can't create, skip sound
            }
            
            try {
                // Create a footstep sound (thud/tap like)
                const duration = 0.15; // 150ms
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);
                
                // Generate footstep waveform (impact + low thud)
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / sampleRate;
                    let sample = 0;
                    
                    // Initial impact (high frequency tap)
                    const impactFreq = 800 + Math.random() * 200; // Random between 800-1000Hz
                    sample += Math.sin(t * impactFreq * 2 * Math.PI) * 0.3 * Math.exp(-t * 30);
                    
                    // Low frequency thud (bass)
                    sample += Math.sin(t * 80 * 2 * Math.PI) * 0.4;
                    sample += Math.sin(t * 120 * 2 * Math.PI) * 0.2;
                    
                    // Add texture with filtered noise (like ground contact)
                    const noise = (Math.random() * 2 - 1) * 0.15;
                    const noiseFilter = Math.exp(-t * 15); // High frequency decays quickly
                    sample += noise * noiseFilter;
                    
                    // Envelope: very quick attack, medium decay
                    const attack = Math.min(1, t / 0.01); // 10ms attack
                    const decay = Math.max(0, 1 - (t - 0.01) / (duration - 0.01));
                    const envelope = attack * decay;
                    data[i] = sample * envelope * 0.2; // Volume
                }
                
                // Play the sound
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0.375; // Volume level (increased by 25%)
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(0);
            } catch (error) {
                // Silently fail if audio can't play
            }
        }
        
        // Load high score from localStorage
        function loadHighScore() {
            const savedHighScore = localStorage.getItem('zombieSurvivalHighScore');
            if (savedHighScore !== null) {
                highScore = parseInt(savedHighScore);
            }
        }
        
        // Save high score to localStorage
        function saveHighScore() {
            if (zombiesKilled > highScore) {
                highScore = zombiesKilled;
                localStorage.setItem('zombieSurvivalHighScore', highScore.toString());
            }
        }

        // Pause menu functions
        function togglePause() {
            if (gameRunning && !gameHUD.gameOver) {
                if (gamePaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
            }
        }

        function pauseGame() {
            gamePaused = true;
            gameHUD.showPauseMenu();
        }

        function resumeGame() {
            gamePaused = false;
            gameHUD.hidePauseMenu();
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            // Don't process game keys if main menu is showing
            if (showMainMenu) return;
            
            keys[e.key.toLowerCase()] = true;
            // Pause/unpause on ESC key
            if (e.key === 'Escape') {
                togglePause();
            }

            // Weapon switching
            if (e.key === '1') {
                switchWeapon(weapons.pistol);
            }
            if (e.key === '2') {
                switchWeapon(weapons.shotgun);
            }
            if (e.key === '3') {
                switchWeapon(weapons.rifle);
            }
            // Throw grenade
            if (e.key === 'g' || e.key === 'G') {
                throwGrenade();
            }
            // Reload on R key when game is running
            if ((e.key === 'r' || e.key === 'R') && gameRunning && !gamePaused) {
                reloadWeapon();
            }

            // Handle keys for paused/game over state
            if (gamePaused || !gameRunning) {
                if (e.key === 'r' || e.key === 'R') {
                    restartGame();
                }
                if (gamePaused && (e.key === 'm' || e.key === 'M')) {
                    restartGame(); // restartGame also handles returning to menu
                }
            }
        });
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouse.x = (e.clientX - rect.left) * scaleX;
            mouse.y = (e.clientY - rect.top) * scaleY;
            
            // Update menu button hover state
            if (showMainMenu) {
                gameHUD.updateMenuHover(mouse.x, mouse.y);
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            if (showMainMenu) {
                // Handle main menu button clicks
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clickX = (e.clientX - rect.left) * scaleX;
                const clickY = (e.clientY - rect.top) * scaleY;
                
                const clickedButton = gameHUD.checkMenuButtonClick(clickX, clickY);
                if (clickedButton === 'single') {
                    // Start single player game
                    showMainMenu = false;
                    initAudio(); // Initialize audio on first user interaction
                    startGame(); // Initialize and start the game
                } else if (clickedButton === 'multiplayer') {
                    // Multiplayer button clicked - do nothing (non-functional)
                    // Could play a sound or show feedback here
                }
                return;
            }
            
            if (gameRunning && !gamePaused) {
                initAudio(); // Initialize audio on first user interaction
                mouse.isDown = true;
                shootBullet(); // Fire immediately on mouse down
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouse.isDown = false;
        });

        // Also handle mouse leave to stop firing
        canvas.addEventListener('mouseleave', () => {
            mouse.isDown = false;
        });

        class Shell {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.size = 5; // Size of the shell casing
                this.color = 'rgb(180, 160, 0)'; // Brass color

                // Initial velocity for the shell to eject
                const speed = 2 + Math.random() * 3; // Reduced speed
                // Eject slightly away from the player's firing angle
                // Assuming angle is player's aim angle, eject slightly backwards/sideways
                const ejectAngle = angle + (Math.PI / 2) + (Math.random() - 0.5) * Math.PI / 4; // 90 degrees offset + some randomness

                this.vx = Math.cos(ejectAngle) * speed;
                this.vy = Math.sin(ejectAngle) * speed;

                this.rotation = Math.random() * Math.PI * 2; // Initial random rotation
                this.rotationSpeed = (Math.random() - 0.5) * 0.5; // Random rotation speed

                this.life = 60; // How many frames the shell stays alive (e.g., 1 second at 60 FPS)
                this.fadeThreshold = 30; // When to start fading
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rotationSpeed;

                // Apply some drag/friction to slow down
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.rotationSpeed *= 0.95;

                // Apply a tiny bit of "gravity" for a more natural fall-like arc in top-down view
                this.vy += 0.1;

                this.life--;
            }

            draw(ctx) {
                if (this.life <= 0) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // Apply fading effect
                let alpha = 1;
                if (this.life < this.fadeThreshold) {
                    alpha = this.life / this.fadeThreshold;
                }
                ctx.fillStyle = `rgba(${parseInt(this.color.substring(4, 7))}, ${parseInt(this.color.substring(9, 12))}, ${parseInt(this.color.substring(14, 17))}, ${alpha})`;

                ctx.fillRect(-this.size / 2, -this.size / 4, this.size, this.size / 2); // Draw a small rectangle for the shell
                ctx.restore();
            }
        }

        // Bullet class
        class Bullet {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.radius = 4;
                this.speed = 8;
                this.angle = angle;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.damage = currentWeapon.damage; // Weapon-specific damage
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                // Bullet glow
                const bulletGlow = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 2);
                bulletGlow.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                bulletGlow.addColorStop(1, 'rgba(255, 255, 0, 0)');
                ctx.fillStyle = bulletGlow;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Bullet core
                const bulletGradient = ctx.createRadialGradient(this.x - 1, this.y - 1, 0, this.x, this.y, this.radius);
                bulletGradient.addColorStop(0, '#ffffff');
                bulletGradient.addColorStop(0.5, '#ffff00');
                bulletGradient.addColorStop(1, '#ffaa00');
                ctx.fillStyle = bulletGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Bullet outline
                ctx.strokeStyle = '#cc8800';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            isOffScreen() {
                return this.x < 0 || this.x > canvas.width || 
                       this.y < 0 || this.y > canvas.height;
            }
        }

        // Grenade class
        class Grenade {
            constructor(x, y, targetX, targetY) {
                this.x = x;
                this.y = y;
                this.radius = 6;
                this.targetX = targetX;
                this.targetY = targetY;
                this.gravity = 0.3; // Gravity effect
                this.bounce = 0.4; // Bounce when hitting ground
                this.onGround = false;
                this.fuseTime = GRENADE_FUSE_TIME; // Time until explosion
                this.createdAt = Date.now();
                this.exploded = false;
                
                // Calculate trajectory to reach target
                const dx = targetX - x;
                const dy = targetY - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Calculate desired flight time in frames (assuming ~60fps)
                // Closer targets = faster, farther = slower but still reasonable
                const framesToTarget = Math.max(40, Math.min(100, distance / 3.5)); // 0.67 to 1.67 seconds at 60fps
                
                // Horizontal velocity (straightforward)
                this.vx = dx / framesToTarget;
                
                // Vertical velocity - account for gravity over flight time
                // We want: finalY = startY + vy * frames + 0.5 * gravity * frames^2
                // Solving: vy = (finalY - startY - 0.5 * gravity * frames^2) / frames
                const totalGravityEffect = 0.5 * this.gravity * framesToTarget * framesToTarget;
                this.vy = (dy - totalGravityEffect) / framesToTarget;
                
                // Debug: Log trajectory info
                // console.log(`Grenade: start(${x.toFixed(1)}, ${y.toFixed(1)}) target(${targetX.toFixed(1)}, ${targetY.toFixed(1)}) vx=${this.vx.toFixed(2)} vy=${this.vy.toFixed(2)} frames=${framesToTarget.toFixed(0)}`);
                
                // Ensure we have enough upward velocity for a visible arc
                // Always give some upward component for arc, even when throwing down
                if (this.vy > -3) {
                    // If calculated vy is too low (not enough arc), add upward component
                    this.vy = Math.min(this.vy, -3); // Minimum upward arc
                }
            }

            update() {
                // Don't update if already exploded
                if (this.exploded) return;
                
                // Update fuse timer first
                const elapsed = Date.now() - this.createdAt;
                if (elapsed >= this.fuseTime) {
                    this.explode();
                    return; // Explode immediately, don't update position
                }
                
                // Only update physics if not on ground and not exploded
                if (!this.onGround) {
                    // Apply gravity
                    this.vy += this.gravity;
                    
                    // Update position
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // Keep within canvas bounds (horizontal)
                    if (this.x < this.radius) {
                        this.x = this.radius;
                        this.vx *= -0.6; // Bounce off left wall
                    }
                    if (this.x > canvas.width - this.radius) {
                        this.x = canvas.width - this.radius;
                        this.vx *= -0.6; // Bounce off right wall
                    }
                    
                    // Keep within canvas bounds (vertical - top only, allow going down)
                    if (this.y < this.radius) {
                        this.y = this.radius;
                        this.vy *= -0.4; // Bounce off top
                    }
                    
                    // Check distance to target after moving
                    const dxToTarget = this.targetX - this.x;
                    const dyToTarget = this.targetY - this.y;
                    const distToTarget = Math.sqrt(dxToTarget * dxToTarget + dyToTarget * dyToTarget);
                    
                    // Determine if we're still moving toward the target
                    const dot = this.vx * dxToTarget + this.vy * dyToTarget;
                    
                    // If we are very close to target, snap to it and stop
                    if (distToTarget <= 15) {
                        this.x = this.targetX;
                        this.y = this.targetY;
                        this.vx = 0;
                        this.vy = 0;
                        this.onGround = true;
                    }
                    // If we've passed the target (moving away) and are close enough, snap to it
                    else if (dot < 0 && distToTarget <= 30) {
                        this.x = this.targetX;
                        this.y = this.targetY;
                        this.vx = 0;
                        this.vy = 0;
                        this.onGround = true;
                    }
                    // Safety ground collision (only if target is at bottom)
                    else if (this.y >= canvas.height - this.radius) {
                        // Only stop at ground if target is also near ground
                        if (this.targetY >= canvas.height - 30) {
                            this.y = canvas.height - this.radius;
                            if (!this.onGround) {
                                this.vy *= -this.bounce;
                                this.vx *= 0.7;
                                this.onGround = true;
                            } else {
                                this.vy = 0;
                                this.vx *= 0.9;
                            }
                        }
                        // If target is above ground, let it continue (will be caught by target check)
                    }
                } else {
                    // On ground - still apply horizontal friction
                    this.vx *= 0.9;
                    if (Math.abs(this.vx) < 0.1) {
                        this.vx = 0;
                    }
                }
            }

            explode() {
                if (this.exploded) return;
                this.exploded = true;
                
                // Create explosion visual effect
                createExplosion(this.x, this.y);
                
                // Screen shake
                shakeAmount = 15;
                
                // AOE damage to zombies
                zombies.forEach((zombie, zombieIndex) => {
                    const dx = zombie.x - this.x;
                    const dy = zombie.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= GRENADE_EXPLOSION_RADIUS) {
                        // Damage decreases with distance
                        const damageMultiplier = 1 - (distance / GRENADE_EXPLOSION_RADIUS) * 0.5; // 50% to 100% damage
                        const damage = Math.floor(GRENADE_DAMAGE * damageMultiplier);
                        
                        if (zombie.takeDamage(damage)) {
                            zombies.splice(zombieIndex, 1);
                            score += 10;
                            zombiesKilled++;
                            createBloodSplatter(zombie.x, zombie.y, Math.atan2(dy, dx), true);
                        } else {
                            createBloodSplatter(zombie.x, zombie.y, Math.atan2(dy, dx), false);
                        }
                    }
                });
                
                // Play explosion sound
                playExplosionSound();
            }

            draw() {
                // Don't draw if exploded
                if (this.exploded) return;
                
                // Fuse indicator (pulsing when close to explosion)
                const elapsed = Date.now() - this.createdAt;
                const timeLeft = Math.max(0, this.fuseTime - elapsed);
                const pulse = timeLeft < 500 ? Math.sin(Date.now() / 50) * 0.3 + 0.7 : 1;
                
                // Grenade body (dark green/olive)
                const grenadeGradient = ctx.createRadialGradient(this.x - 2, this.y - 2, 0, this.x, this.y, this.radius);
                grenadeGradient.addColorStop(0, '#8b7355');
                grenadeGradient.addColorStop(0.5, '#6b5d3f');
                grenadeGradient.addColorStop(1, '#4a3d2a');
                ctx.fillStyle = grenadeGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Grenade segments (pineapple style)
                ctx.strokeStyle = '#3a2d1a';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                // Horizontal lines
                ctx.moveTo(this.x - this.radius, this.y - 2);
                ctx.lineTo(this.x + this.radius, this.y - 2);
                ctx.moveTo(this.x - this.radius, this.y);
                ctx.lineTo(this.x + this.radius, this.y);
                ctx.moveTo(this.x - this.radius, this.y + 2);
                ctx.lineTo(this.x + this.radius, this.y + 2);
                ctx.stroke();
                
                // Fuse (red when close to explosion)
                if (timeLeft < 500) {
                    ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                } else {
                    ctx.fillStyle = '#ffaa00';
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y - this.radius - 2, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Glow when close to explosion
                if (timeLeft < 500) {
                    const glowGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 3);
                    glowGradient.addColorStop(0, `rgba(255, 100, 0, ${0.4 * pulse})`);
                    glowGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Base Zombie class (shared behaviour for all zombie types)
        class Zombie {
            constructor() {
                const side = Math.floor(Math.random() * 4);
                switch(side) {
                    case 0: this.x = Math.random() * canvas.width; this.y = -20; break;
                    case 1: this.x = canvas.width + 20; this.y = Math.random() * canvas.height; break;
                    case 2: this.x = Math.random() * canvas.width; this.y = canvas.height + 20; break;
                    case 3: this.x = -20; this.y = Math.random() * canvas.height; break;
                }
                this.radius = 12;
                this.speed = 1 + (wave * 0.1);
                this.health = 2 + Math.floor(wave / 3);
                this.type = 'base';
            }

            update() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
            }

            draw() {
                // Shadow (larger and more ominous)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.ellipse(this.x + 3, this.y + this.radius + 3, this.radius * 1.2, this.radius * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Toxic aura (pulsing outer glow)
                const pulse = Math.sin(Date.now() / 250) * 0.4 + 0.6;
                const auraGradient = ctx.createRadialGradient(this.x, this.y, this.radius * 0.5, this.x, this.y, this.radius * 2);
                auraGradient.addColorStop(0, `rgba(0, 255, 0, ${0.4 * pulse})`);
                auraGradient.addColorStop(0.5, `rgba(50, 255, 50, ${0.2 * pulse})`);
                auraGradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Zombie torso (singular piece of body) - drawn BEFORE head for proper layering
                const bodyGradient = ctx.createRadialGradient(this.x - 4, this.y - 4, 0, this.x, this.y, this.radius);
                bodyGradient.addColorStop(0, '#9acd32');
                bodyGradient.addColorStop(0.4, '#7cb342');
                bodyGradient.addColorStop(0.7, '#558b2f');
                bodyGradient.addColorStop(1, '#33691e');
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.ellipse(this.x, this.y + 15, this.radius * 1.2, this.radius * 1.5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Zombie arm (singular piece of body) - drawn BEFORE head for proper layering
                ctx.strokeStyle = '#1b3a00';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(this.x - 8, this.y + 10);
                ctx.lineTo(this.x - 15, this.y + 18);
                ctx.stroke();
                
                // Decayed flesh body (head)
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Zombie skin texture (darker patches)
                ctx.fillStyle = 'rgba(30, 60, 10, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x + 4, this.y - 2, 3, 0, Math.PI * 2);
                ctx.arc(this.x - 3, this.y + 5, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Body outline (rough edges)
                ctx.strokeStyle = '#1b3a00';
                ctx.lineWidth = 2.5;
                ctx.setLineDash([2, 1]);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Eye sockets (darker areas)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.beginPath();
                ctx.ellipse(this.x - 5, this.y - 3, 4, 5, 0, 0, Math.PI * 2);
                ctx.ellipse(this.x + 5, this.y - 3, 4, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Glowing zombie eyes (animated intensity)
                const eyePulse = Math.sin(Date.now() / 167) * 0.3 + 0.7;
                ctx.shadowBlur = 10 * eyePulse;
                ctx.shadowColor = '#ff0000';
                
                // Eye glow gradient
                const eyeGradient = ctx.createRadialGradient(this.x - 5, this.y - 3, 0, this.x - 5, this.y - 3, 3);
                eyeGradient.addColorStop(0, '#ff6666');
                eyeGradient.addColorStop(0.5, '#ff0000');
                eyeGradient.addColorStop(1, '#990000');
                ctx.fillStyle = eyeGradient;
                ctx.beginPath();
                ctx.arc(this.x - 5, this.y - 3, 3, 0, Math.PI * 2);
                ctx.fill();
                
                const eyeGradient2 = ctx.createRadialGradient(this.x + 5, this.y - 3, 0, this.x + 5, this.y - 3, 3);
                eyeGradient2.addColorStop(0, '#ff6666');
                eyeGradient2.addColorStop(0.5, '#ff0000');
                eyeGradient2.addColorStop(1, '#990000');
                ctx.fillStyle = eyeGradient2;
                ctx.beginPath();
                ctx.arc(this.x + 5, this.y - 3, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Eye highlights
                ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                ctx.beginPath();
                ctx.arc(this.x - 6, this.y - 4, 1, 0, Math.PI * 2);
                ctx.arc(this.x + 4, this.y - 4, 1, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // Jagged mouth (open and menacing)
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(this.x - 6, this.y + 5);
                ctx.quadraticCurveTo(this.x - 3, this.y + 8, this.x, this.y + 7);
                ctx.quadraticCurveTo(this.x + 3, this.y + 8, this.x + 6, this.y + 5);
                ctx.stroke();
                
                // Teeth
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(this.x - 4, this.y + 5);
                ctx.lineTo(this.x - 4, this.y + 7);
                ctx.moveTo(this.x - 1, this.y + 6);
                ctx.lineTo(this.x - 1, this.y + 8);
                ctx.moveTo(this.x + 2, this.y + 6);
                ctx.lineTo(this.x + 2, this.y + 8);
                ctx.moveTo(this.x + 4, this.y + 5);
                ctx.lineTo(this.x + 4, this.y + 7);
                ctx.stroke();
                
                // Dripping effect (zombie drool/decay)
                const dripAnim = (Date.now() / 50 + this.x) % 10;
                if (dripAnim < 5) {
                    ctx.fillStyle = 'rgba(100, 150, 50, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(this.x + 7, this.y + 8 + dripAnim * 0.5, 1, 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            takeDamage(bulletDamage) {
                this.health -= bulletDamage;
                return this.health <= 0;
            }
        }

        // Normal zombie - current default enemy type
        class NormalZombie extends Zombie {
            constructor() {
                super();
                this.type = 'normal';
            }
        }

        // Armored zombie - slower but much tougher, with armor that absorbs damage
        class ArmoredZombie extends Zombie {
            constructor() {
                super();
                this.type = 'armored';
                this.armor = 10 + Math.floor(wave * 1.5); // Armor pool scales with wave
                this.speed *= 0.75; // Heavier, slower
                this.radius += 2;   // Slightly larger visual silhouette
            }

            draw() {
                // Draw base zombie visuals
                super.draw();

                // Overlay metal armor plates
                ctx.save();
                ctx.translate(this.x, this.y);

                // Chest plate
                ctx.fillStyle = 'rgba(140, 140, 155, 0.96)';
                ctx.strokeStyle = '#303030';
                ctx.lineWidth = 2;
                const chestWidth = this.radius * 1.8;
                const chestHeight = this.radius * 1.1;
                ctx.beginPath();
                ctx.rect(-chestWidth / 2, this.radius * 0.2, chestWidth, chestHeight);
                ctx.fill();
                ctx.stroke();

                // Shoulder pads
                ctx.beginPath();
                ctx.arc(-this.radius * 0.9, this.radius * 0.3, this.radius * 0.5, 0, Math.PI * 2);
                ctx.arc(this.radius * 0.9, this.radius * 0.3, this.radius * 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Helmet band
                ctx.beginPath();
                ctx.rect(-this.radius * 0.9, -this.radius * 1.2, this.radius * 1.8, this.radius * 0.4);
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            }

            takeDamage(bulletDamage) {
                // Armor absorbs most of the damage first; some always leaks through
                const armorLeakThrough = 0.35; // 35% of damage bypasses armor
                let remaining = bulletDamage;

                if (this.armor > 0) {
                    const toArmor = remaining * (1 - armorLeakThrough);
                    this.armor -= toArmor;
                    remaining = remaining * armorLeakThrough;
                }

                if (remaining > 0) {
                    this.health -= remaining;
                }

                return this.health <= 0;
            }
        }

        class DamageNumber {
            constructor(x, y, value) {
                this.x = x + (Math.random() - 0.5) * 10; // Start at zombie's x with some jitter
                this.y = y;
                this.value = value;
                this.life = 60; // 1 second at 60fps
                this.maxLife = 60;
                this.vy = -1.5; // Upward velocity
                this.vx = (Math.random() - 0.5) * 0.5; // Slight horizontal drift
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.03; // A bit of gravity to slow the ascent
                this.life--;
            }

            draw(ctx) {
                if (this.life <= 0) return;
                ctx.save();
                const alpha = Math.max(0, this.life / this.maxLife);
                ctx.fillStyle = `rgba(255, 255, 100, ${alpha})`; // Yellow color for damage
                ctx.font = 'bold 16px "Roboto Mono", monospace';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                ctx.shadowBlur = 4;
                ctx.fillText(this.value, this.x, this.y);
                ctx.restore();
            }
        }

        // Particle class for effects
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 3 + 1;
                this.color = color;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.life = 30;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life / 30;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Simple health pickup (healing orb with cross icon)
        class HealthPickup {
            constructor() {
                const margin = 40;
                this.radius = 10;
                this.x = margin + Math.random() * (canvas.width - margin * 2);
                this.y = margin + Math.random() * (canvas.height - margin * 2);
                this.pulseOffset = Math.random() * Math.PI * 2;
            }

            draw() {
                const t = Date.now() / 500 + this.pulseOffset;
                const pulse = 0.8 + Math.sin(t) * 0.15;

                // Outer glow
                const glowRadius = this.radius * 2.2 * pulse;
                const glowGradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, glowRadius
                );
                glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                glowGradient.addColorStop(1, 'rgba(255, 0, 80, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowRadius, 0, Math.PI * 2);
                ctx.fill();

                // Main disc
                const coreGradient = ctx.createRadialGradient(
                    this.x - 2, this.y - 2, 0,
                    this.x, this.y, this.radius
                );
                coreGradient.addColorStop(0, '#ff8a80');
                coreGradient.addColorStop(1, '#d50000');
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // White cross icon
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x - this.radius / 2, this.y);
                ctx.lineTo(this.x + this.radius / 2, this.y);
                ctx.moveTo(this.x, this.y - this.radius / 2);
                ctx.lineTo(this.x, this.y + this.radius / 2);
                ctx.stroke();
            }
        }

        // Ammo pickup (ammo box with bullet icon)
        class AmmoPickup {
            constructor() {
                const margin = 40;
                this.radius = 10;
                this.x = margin + Math.random() * (canvas.width - margin * 2);
                this.y = margin + Math.random() * (canvas.height - margin * 2);
                this.pulseOffset = Math.random() * Math.PI * 2;
            }

            draw() {
                const t = Date.now() / 500 + this.pulseOffset;
                const pulse = 0.8 + Math.sin(t) * 0.15;

                // Outer glow (yellow/orange)
                const glowRadius = this.radius * 2.2 * pulse;
                const glowGradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, glowRadius
                );
                glowGradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
                glowGradient.addColorStop(1, 'rgba(255, 152, 0, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowRadius, 0, Math.PI * 2);
                ctx.fill();

                // Main disc (yellow/orange)
                const coreGradient = ctx.createRadialGradient(
                    this.x - 2, this.y - 2, 0,
                    this.x, this.y, this.radius
                );
                coreGradient.addColorStop(0, '#ffd54f');
                coreGradient.addColorStop(1, '#ff9800');
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Bullet icon (simple rectangle with point)
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x - this.radius * 0.4, this.y - this.radius * 0.3, this.radius * 0.8, this.radius * 0.6);
                // Bullet tip
                ctx.beginPath();
                ctx.moveTo(this.x + this.radius * 0.4, this.y - this.radius * 0.3);
                ctx.lineTo(this.x + this.radius * 0.6, this.y);
                ctx.lineTo(this.x + this.radius * 0.4, this.y + this.radius * 0.3);
                ctx.fill();
            }
        }

        function shootBullet() {
            const now = Date.now();
            
            // Check if reloading
            if (isReloading) {
                if (now - reloadStartTime >= currentWeapon.reloadTime) {
                    isReloading = false;
                    currentAmmo = currentWeapon.maxAmmo;
                } else {
                    return; // Still reloading
                }
            }
            
            // Check fire rate cooldown
            if (now - lastShotTime < currentWeapon.fireRate) {
                return;
            }
            
            // Check ammo
            if (currentAmmo <= 0) {
                reloadWeapon();
                return;
            }
            
            const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            const gunX = player.x + Math.cos(angle) * player.radius * 1.8;
            const gunY = player.y + Math.sin(angle) * player.radius * 1.8;
            
            // Create bullets based on weapon type
            if (currentWeapon === weapons.shotgun) {
                // Shotgun fires 5 spread bullets
                for (let i = 0; i < 5; i++) {
                    const spreadAngle = angle + (Math.random() - 0.5) * 0.5; // Add spread
                    bullets.push(new Bullet(gunX, gunY, spreadAngle));
                }
            } else {
                // Pistol and rifle fire single bullet
                bullets.push(new Bullet(gunX, gunY, angle));
            }
            
            // Consume ammo
            currentAmmo--;
            
            // Update last shot time
            lastShotTime = now;
            
            // Add screen shake on shoot
            shakeAmount = 3;
            
            // Trigger muzzle flash
            triggerMuzzleFlash(gunX, gunY, angle);
            
            // Create shell casing
            shells.push(new Shell(gunX, gunY, angle));
            
            // Play gunshot sound
            playGunshotSound();
        }
        
        function reloadWeapon() {
            if (!isReloading && currentAmmo < currentWeapon.maxAmmo) {
                isReloading = true;
                reloadStartTime = Date.now();
                // Play reload sound if implemented
            }
        }
        
        function switchWeapon(weapon) {
            if (weapon !== currentWeapon) {
                currentWeapon = weapon;
                currentAmmo = currentWeapon.ammo;
                maxAmmo = currentWeapon.maxAmmo;
                lastShotTime = 0; // Reset fire rate cooldown
                isReloading = false; // Cancel any ongoing reload
            }
        }
        
        function spawnZombies(count) {
            // Clear any pending zombie spawn timeouts
            zombieSpawnTimeouts.forEach(timeout => clearTimeout(timeout));
            zombieSpawnTimeouts = [];
            
            // Mark that we're spawning a wave
            isSpawningWave = true;
            
            // Spawn zombies with staggered timing
            for (let i = 0; i < count; i++) {
                const timeout = setTimeout(() => {
                    // Chance for armored zombies increases with wave
                    let spawnArmored = false;
                    if (wave >= 3) {
                        const armoredChance = Math.min(0.1 + wave * 0.03, 0.5); // 10%+ and caps at 50%
                        spawnArmored = Math.random() < armoredChance;
                    }

                    if (spawnArmored) {
                        zombies.push(new ArmoredZombie());
                    } else {
                        zombies.push(new NormalZombie());
                    }
                    // After the last zombie spawns, clear the flag
                    if (i === count - 1) {
                        isSpawningWave = false;
                    }
                }, i * 500);
                zombieSpawnTimeouts.push(timeout);
            }
        }

        // Limit the total number of active particles to keep performance stable on high waves
        const MAX_PARTICLES = 500;

        function addParticle(particle) {
            particles.push(particle);
            if (particles.length > MAX_PARTICLES) {
                // Drop oldest particles first (they are already nearly faded out)
                particles.splice(0, particles.length - MAX_PARTICLES);
            }
        }

        // Health pickup spawn timing
        let lastHealthPickupSpawnTime = Date.now();
        
        // Ammo pickup spawn timing
        let lastAmmoPickupSpawnTime = Date.now();

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                addParticle(new Particle(x, y, color));
            }
        }

        // Create blood splatter particles when zombie is hit or killed
        function createBloodSplatter(x, y, angle, isKill = false) {
            const particleCount = isKill ? 12 : 5; // More particles on kill
            const bloodColors = ['#8b0000', '#a52a2a', '#dc143c', '#b22222', '#8b0000']; // Dark reds to bright red
            
            for (let i = 0; i < particleCount; i++) {
                // Directional splatter - particles spread from impact point
                const spreadAngle = angle + (Math.random() - 0.5) * Math.PI; // Spread in direction of impact
                const speed = isKill ? (Math.random() * 6 + 2) : (Math.random() * 4 + 1);
                const vx = Math.cos(spreadAngle) * speed;
                const vy = Math.sin(spreadAngle) * speed;
                
                // Create blood particle with custom properties
                const bloodParticle = {
                    x: x,
                    y: y,
                    radius: Math.random() * 2.5 + 1.5, // Slightly larger blood droplets
                    color: bloodColors[Math.floor(Math.random() * bloodColors.length)],
                    vx: vx,
                    vy: vy,
                    life: isKill ? 40 : 25, // Longer life for kill splatter
                    maxLife: isKill ? 40 : 25
                };
                
                addParticle(bloodParticle);
            }
            
            // Also create some ground splatter (larger, darker patches)
            if (isKill) {
                for (let i = 0; i < 3; i++) {
                    const groundParticle = {
                        x: x + (Math.random() - 0.5) * 15,
                        y: y + (Math.random() - 0.5) * 15,
                        radius: Math.random() * 4 + 3, // Larger ground patches
                        color: '#5a0000', // Very dark red
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        life: 60,
                        maxLife: 60
                    };
                    addParticle(groundParticle);
                }
            }
        }

        function checkCollision(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < obj1.radius + obj2.radius;
        }

        // Create explosion visual effect
        function createExplosion(x, y) {
            // Large flash
            const flashParticle = {
                x: x,
                y: y,
                radius: GRENADE_EXPLOSION_RADIUS,
                color: '#ff6600',
                life: 10,
                maxLife: 10,
                vx: 0,
                vy: 0
            };
            addParticle(flashParticle);
            
            // Fire particles
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 / 30) * i;
                const speed = Math.random() * 4 + 2;
                const fireParticle = {
                    x: x,
                    y: y,
                    radius: Math.random() * 3 + 2,
                    color: ['#ff6600', '#ff8800', '#ffaa00', '#ffff00'][Math.floor(Math.random() * 4)],
                    life: Math.random() * 20 + 15,
                    maxLife: Math.random() * 20 + 15,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed
                };
                addParticle(fireParticle);
            }
            
            // Smoke particles
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2 + 1;
                const smokeParticle = {
                    x: x,
                    y: y,
                    radius: Math.random() * 4 + 3,
                    color: `rgba(80, 80, 80, ${Math.random() * 0.5 + 0.3})`,
                    life: Math.random() * 30 + 20,
                    maxLife: Math.random() * 30 + 20,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed
                };
                addParticle(smokeParticle);
            }
        }

        // Play explosion sound
        function playExplosionSound() {
            if (!audioContext) {
                initAudio();
                if (!audioContext) return;
            }
            
            try {
                const duration = 0.4; // 400ms
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);
                
                // Generate explosion waveform (low rumble with high crack)
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / sampleRate;
                    let sample = 0;
                    // Low frequency rumble
                    sample += Math.sin(t * 60 * 2 * Math.PI) * 0.4;
                    sample += Math.sin(t * 120 * 2 * Math.PI) * 0.3;
                    // High frequency crack
                    sample += Math.sin(t * 800 * 2 * Math.PI) * 0.2 * Math.exp(-t * 5);
                    // Envelope: quick attack, slow decay
                    const envelope = Math.exp(-t * 2);
                    data[i] = sample * envelope * 0.3;
                }
                
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0.4;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(0);
            } catch (error) {
                // Silently fail if audio can't play
            }
        }

        // Throw grenade
        function throwGrenade() {
            const now = Date.now();
            
            // Check cooldown
            if (now - lastGrenadeThrowTime < GRENADE_COOLDOWN) {
                return;
            }
            
            // Check grenade count
            if (grenadeCount <= 0) {
                return;
            }
            
            // Calculate throw position (from player)
            const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            const throwX = player.x + Math.cos(angle) * player.radius * 1.5;
            const throwY = player.y + Math.sin(angle) * player.radius * 1.5;
            
            // Target is where the mouse cursor is (ensure it's within canvas bounds)
            const targetX = Math.max(20, Math.min(canvas.width - 20, mouse.x));
            const targetY = Math.max(20, Math.min(canvas.height - 20, mouse.y));
            
            // Debug log (uncomment to debug)
            // console.log(`Throwing grenade from (${throwX.toFixed(1)}, ${throwY.toFixed(1)}) to (${targetX.toFixed(1)}, ${targetY.toFixed(1)})`);
            
            grenades.push(new Grenade(throwX, throwY, targetX, targetY));
            grenadeCount--;
            lastGrenadeThrowTime = now;
            
            // Small screen shake on throw
            shakeAmount = 2;
        }

        function triggerDamageIndicator() {
            damageIndicator.active = true;
            damageIndicator.intensity = 1.0;
        }

        function triggerWaveNotification() {
            waveNotification.active = true;
            waveNotification.text = `Wave ${wave} Starting!`;
            waveNotification.life = waveNotification.maxLife;
        }

        function triggerMuzzleFlash(x, y, angle) {
            muzzleFlash.active = true;
            muzzleFlash.intensity = 1.0;
            muzzleFlash.x = x;
            muzzleFlash.y = y;
            muzzleFlash.angle = angle;
            muzzleFlash.life = muzzleFlash.maxLife;
        }

        function updatePlayer() {
            // Don't update player if main menu is showing
            if (showMainMenu) return;
            
            // Check if player is moving
            const isMoving = (keys['w'] || keys['arrowup'] || keys['s'] || keys['arrowdown'] || 
                             keys['a'] || keys['arrowleft'] || keys['d'] || keys['arrowright']);
            
            // Movement
            if (keys['w'] || keys['arrowup']) player.y -= player.speed;
            if (keys['s'] || keys['arrowdown']) player.y += player.speed;
            if (keys['a'] || keys['arrowleft']) player.x -= player.speed;
            if (keys['d'] || keys['arrowright']) player.x += player.speed;

            // Bounds
            player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));

            // Aim
            player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            
            // Footstep sounds
            if (isMoving && gameRunning && !gamePaused) {
                const currentTime = Date.now();
                if (currentTime - lastFootstepTime >= footstepInterval) {
                    playFootstepSound();
                    lastFootstepTime = currentTime;
                }
            } else {
                lastFootstepTime = 0; // Reset when not moving
            }
        }

        function drawPlayer() {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(player.x + 2, player.y + player.radius + 2, player.radius * 0.8, player.radius * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Outer glow
            const gradient = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, player.radius * 1.5);
            gradient.addColorStop(0, 'rgba(0, 136, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 136, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius * 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Body
            const bodyGradient = ctx.createRadialGradient(player.x - 5, player.y - 5, 0, player.x, player.y, player.radius);
            bodyGradient.addColorStop(0, '#66b3ff');
            bodyGradient.addColorStop(1, '#0066cc');
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Body outline
            ctx.strokeStyle = '#003d7a';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Direction indicator (gun)
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            const gunX = player.x + Math.cos(player.angle) * player.radius * 1.8;
            const gunY = player.y + Math.sin(player.angle) * player.radius * 1.8;
            ctx.lineTo(gunX, gunY);
            ctx.stroke();
            
            // Gun tip
            ctx.fillStyle = '#ffaa00';
            ctx.beginPath();
            ctx.arc(gunX, gunY, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Muzzle flash
            if (muzzleFlash.active) {
                const flashSize = 8 + (muzzleFlash.intensity * 12);
                const flashOffset = -2; // Slightly in front of gun
                const flashX = muzzleFlash.x + Math.cos(muzzleFlash.angle) * flashOffset;
                const flashY = muzzleFlash.y + Math.sin(muzzleFlash.angle) * flashOffset;
                
                // Outer glow (bright white/yellow)
                const flashGradient = ctx.createRadialGradient(
                    flashX, flashY, 0,
                    flashX, flashY, flashSize
                );
                flashGradient.addColorStop(0, `rgba(255, 255, 255, ${muzzleFlash.intensity * 0.9})`);
                flashGradient.addColorStop(0.3, `rgba(255, 255, 200, ${muzzleFlash.intensity * 0.7})`);
                flashGradient.addColorStop(0.6, `rgba(255, 200, 0, ${muzzleFlash.intensity * 0.4})`);
                flashGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                
                ctx.fillStyle = flashGradient;
                ctx.beginPath();
                ctx.arc(flashX, flashY, flashSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Core flash (very bright)
                const coreGradient = ctx.createRadialGradient(
                    flashX, flashY, 0,
                    flashX, flashY, flashSize * 0.4
                );
                coreGradient.addColorStop(0, `rgba(255, 255, 255, ${muzzleFlash.intensity})`);
                coreGradient.addColorStop(0.5, `rgba(255, 255, 150, ${muzzleFlash.intensity * 0.8})`);
                coreGradient.addColorStop(1, 'rgba(255, 200, 0, 0)');
                
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(flashX, flashY, flashSize * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // Spark particles (small bright dots)
                for (let i = 0; i < 4; i++) {
                    const sparkAngle = muzzleFlash.angle + (Math.PI * 2 * i / 4) + Math.random() * 0.5;
                    const sparkDist = flashSize * 0.6;
                    const sparkX = flashX + Math.cos(sparkAngle) * sparkDist;
                    const sparkY = flashY + Math.sin(sparkAngle) * sparkDist;
                    
                    ctx.fillStyle = `rgba(255, 255, 200, ${muzzleFlash.intensity * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(sparkX, sparkY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawCrosshair() {
            // Don't draw crosshair if game is over or paused
            if (!gameRunning || gamePaused) return;
            
            // Check if mouse is within canvas bounds
            if (mouse.x < 0 || mouse.x > canvas.width || mouse.y < 0 || mouse.y > canvas.height) return;
            
            ctx.save();
            
            // Determine crosshair color based on reload state
            const crosshairColorCurrent = isReloading ? '#888888' : crosshairColor;
            
            // Draw crosshair outline for better visibility
            ctx.strokeStyle = crosshairOutlineColor;
            ctx.lineWidth = crosshairLineWidth + 2;
            ctx.lineCap = 'round';
            
            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(mouse.x - crosshairSize, mouse.y);
            ctx.lineTo(mouse.x + crosshairSize, mouse.y);
            ctx.stroke();
            
            // Vertical line
            ctx.beginPath();
            ctx.moveTo(mouse.x, mouse.y - crosshairSize);
            ctx.lineTo(mouse.x, mouse.y + crosshairSize);
            ctx.stroke();
            
            // Draw crosshair main color
            ctx.strokeStyle = crosshairColorCurrent;
            ctx.lineWidth = crosshairLineWidth;
            
            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(mouse.x - crosshairSize, mouse.y);
            ctx.lineTo(mouse.x + crosshairSize, mouse.y);
            ctx.stroke();
            
            // Vertical line
            ctx.beginPath();
            ctx.moveTo(mouse.x, mouse.y - crosshairSize);
            ctx.lineTo(mouse.x, mouse.y + crosshairSize);
            ctx.stroke();
            
            // Small central dot
            ctx.fillStyle = crosshairColorCurrent;
            ctx.beginPath();
            ctx.arc(mouse.x, mouse.y, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        function drawWaveNotification() {
            if (!waveNotification.active) return;

            ctx.save();
            
            const alpha = Math.min(1, waveNotification.life / 30); // Fade in quickly
            const fadeOut = Math.min(1, waveNotification.life / 40); // Fade out at end
            const finalAlpha = alpha * fadeOut;

            // Background glow
            ctx.shadowBlur = 20;
            ctx.shadowColor = `rgba(255, 23, 68, ${finalAlpha * 0.6})`;
            
            // Main text
            ctx.fillStyle = `rgba(255, 255, 255, ${finalAlpha})`;
            ctx.font = 'bold 32px \"Roboto Mono\", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(waveNotification.text, canvas.width / 2, canvas.height / 2 - 40);
            
            // Subtitle
            ctx.fillStyle = `rgba(255, 200, 200, ${finalAlpha * 0.8})`;
            ctx.font = '14px \"Roboto Mono\", monospace';
            ctx.fillText('Get ready...', canvas.width / 2, canvas.height / 2 + 10);
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function drawFpsCounter() {
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '14px \"Roboto Mono\", monospace';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            ctx.fillText(`${fps} FPS`, canvas.width - 20, 20);
            ctx.restore();
        }

        function updateGame() {
            if (!gameRunning || showMainMenu) return;

            const now = Date.now();

            // Spawn health pickups periodically if player isn't at full health
            if (
                now - lastHealthPickupSpawnTime >= HEALTH_PICKUP_SPAWN_INTERVAL &&
                healthPickups.length < MAX_HEALTH_PICKUPS &&
                player.health < PLAYER_MAX_HEALTH
            ) {
                healthPickups.push(new HealthPickup());
                lastHealthPickupSpawnTime = now;
            }
            
            // Spawn ammo pickups periodically if player has low ammo
            if (
                now - lastAmmoPickupSpawnTime >= AMMO_PICKUP_SPAWN_INTERVAL &&
                ammoPickups.length < MAX_AMMO_PICKUPS &&
                currentAmmo < maxAmmo * 0.5 // Spawn when ammo is below 50%
            ) {
                ammoPickups.push(new AmmoPickup());
                lastAmmoPickupSpawnTime = now;
            }

            // Update player
            updatePlayer();

            // Update bullets
            bullets = bullets.filter(bullet => {
                bullet.update();
                return !bullet.isOffScreen();
            });

            // Update grenades
            grenades = grenades.filter(grenade => {
                grenade.update();
                return !grenade.exploded;
            });

            // Update zombies
            zombies.forEach(zombie => zombie.update());

            // Update particles
            particles = particles.filter(particle => {
                // Handle both Particle class instances and custom objects (like blood)
                if (particle.update) {
                    particle.update();
                } else {
                    // Custom particle (blood splatter)
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                }
                return particle.life > 0;
            });

            // Update shells
            shells = shells.filter(shell => {
                shell.update();
                return shell.life > 0;
            });

            // Update damage numbers
            damageNumbers = damageNumbers.filter(num => {
                num.update();
                return num.life > 0;
            });
            
            // Update damage indicator
            if (damageIndicator.active) {
                damageIndicator.intensity *= damageIndicator.decay;
                if (damageIndicator.intensity < 0.1) {
                    damageIndicator.active = false;
                }
            }

            // Update muzzle flash
            if (muzzleFlash.active) {
                muzzleFlash.life--;
                muzzleFlash.intensity = muzzleFlash.life / muzzleFlash.maxLife;
                if (muzzleFlash.life <= 0) {
                    muzzleFlash.active = false;
                }
            }

            // Update wave notification
            if (waveNotification.active) {
                waveNotification.life--;
                if (waveNotification.life <= 0) {
                    waveNotification.active = false;
                }
            }

            // Update reload timer
            if (isReloading) {
                if (now - reloadStartTime >= currentWeapon.reloadTime) {
                    isReloading = false;
                    currentAmmo = currentWeapon.maxAmmo;
                }
            }

            // Continuous firing while mouse button is held
            if (mouse.isDown && gameRunning && !gamePaused) {
                shootBullet();
            }

            // Check bullet-zombie collisions
            bullets.forEach((bullet, bulletIndex) => {
                zombies.forEach((zombie, zombieIndex) => {
                    if (checkCollision(bullet, zombie)) {
                        // Get bullet angle for directional blood splatter
                        const impactAngle = Math.atan2(bullet.vy, bullet.vx);
                        
                        // Check if zombie dies from this hit
                        if (zombie.takeDamage(bullet.damage)) {
                            zombies.splice(zombieIndex, 1);
                            score += 10;
                            zombiesKilled++;
                            // Create floating damage number
                            damageNumbers.push(new DamageNumber(zombie.x, zombie.y, bullet.damage));
                            // Create blood splatter on kill
                            createBloodSplatter(zombie.x, zombie.y, impactAngle, true);
                        } else {
                            // Create floating damage number
                            damageNumbers.push(new DamageNumber(zombie.x, zombie.y, bullet.damage));
                            // Create blood splatter on hit (not kill)
                            createBloodSplatter(zombie.x, zombie.y, impactAngle, false);
                        }
                        bullets.splice(bulletIndex, 1);
                    }
                });
            });

            // Check player-zombie collisions
            zombies.forEach(zombie => {
                if (checkCollision(player, zombie)) {
                    player.health -= 0.5;
                    createParticles(player.x, player.y, '#ff0000', 3);
                    // Add screen shake on damage
                    shakeAmount = 8;
                    // Trigger damage indicator
                    triggerDamageIndicator();
                    // Play damage sound
                    playDamageSound();
                    
                    if (player.health <= 0) {
                        gameOver();
                    }
                }
            });

            // Check player-health pickup collisions
            if (healthPickups.length > 0 && player.health < PLAYER_MAX_HEALTH) {
                healthPickups = healthPickups.filter(pickup => {
                    if (checkCollision(player, pickup)) {
                        player.health = Math.min(
                            PLAYER_MAX_HEALTH,
                            player.health + HEALTH_PICKUP_HEAL_AMOUNT
                        );
                        createParticles(pickup.x, pickup.y, '#ff1744', 8);
                        return false; // remove collected pickup
                    }
                    return true;
                });
            }
            
            // Check player-ammo pickup collisions
            if (ammoPickups.length > 0 && (currentAmmo < maxAmmo || grenadeCount < MAX_GRENADES)) {
                ammoPickups = ammoPickups.filter(pickup => {
                    if (checkCollision(player, pickup)) {
                        // Restore ammo for current weapon
                        currentAmmo = Math.min(maxAmmo, currentAmmo + AMMO_PICKUP_AMOUNT);
                        // Also refill grenades
                        grenadeCount = MAX_GRENADES;
                        createParticles(pickup.x, pickup.y, '#ff9800', 8);
                        return false; // remove collected pickup
                    }
                    return true;
                });
            }

            // Check for next wave (only if not currently spawning)
            if (zombies.length === 0 && gameRunning && !isSpawningWave) {
                wave++;
                zombiesPerWave += 2;
                triggerWaveNotification();
                spawnZombies(zombiesPerWave);
            }
        }

        function drawGame() {
            // Draw main menu if showing
            if (showMainMenu) {
                gameHUD.mainMenu = true;
                canvas.style.cursor = 'default'; // Show cursor on menu
                gameHUD.draw();
                return;
            } else {
                gameHUD.mainMenu = false;
                canvas.style.cursor = 'none'; // Hide cursor during gameplay
            }
            
            // Apply screen shake
            ctx.save();
            if (shakeAmount > 0.1) {
                const shakeX = (Math.random() - 0.5) * shakeAmount;
                const shakeY = (Math.random() - 0.5) * shakeAmount;
                ctx.translate(shakeX, shakeY);
                shakeAmount *= shakeDecay;
            } else {
                shakeAmount = 0;
            }
            
            // Clear canvas with dark gradient
            // Calculate max dimension for gradients (works better for different aspect ratios)
            const maxDimension = Math.max(canvas.width, canvas.height);
            const bgGradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, maxDimension / 1.5);
            bgGradient.addColorStop(0, '#1a1a1a');
            bgGradient.addColorStop(1, '#0d0d0d');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grassy ground pattern (tiled background)
            if (!grassPattern) {
                initGrassPattern();
            }
            ctx.globalAlpha = 0.4; // Make it subtle so it doesn't overpower
            ctx.fillStyle = grassPattern;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1.0; // Reset alpha
            
            // Add subtle vignette effect
            const vignette = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, maxDimension / 3, canvas.width / 2, canvas.height / 2, maxDimension);
            vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
            vignette.addColorStop(1, 'rgba(0, 0, 0, 0.6)');
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw damage indicator
            if (damageIndicator.active) {
                ctx.fillStyle = `rgba(255, 0, 0, ${damageIndicator.intensity * 0.3})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Draw particles
            particles.forEach(particle => {
                if (particle.draw) {
                    // Particle class instance
                    particle.draw();
                } else {
                    // Custom particle (blood splatter)
                    const maxLife = particle.maxLife || 30;
                    ctx.fillStyle = particle.color;
                    ctx.globalAlpha = particle.life / maxLife;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });

            // Draw shells
            shells.forEach(shell => shell.draw(ctx));

            // Draw bullets
            bullets.forEach(bullet => bullet.draw());

            // Draw grenades
            grenades.forEach(grenade => grenade.draw());

            // Draw health pickups (on top of ground but below zombies/player)
            healthPickups.forEach(pickup => pickup.draw());
            
            // Draw ammo pickups
            ammoPickups.forEach(pickup => pickup.draw());

            // Draw zombies
            zombies.forEach(zombie => zombie.draw());

            // Draw player
            drawPlayer();
            
            ctx.restore();

            // Draw damage numbers
            damageNumbers.forEach(num => num.draw(ctx));
            
            // Draw crosshair (after restore so it's not affected by screen shake)
            drawCrosshair();
            
            // Draw in-game HUD (after restore so it's not affected by screen shake)
            gameHUD.draw();

            // Draw wave start notification
            drawWaveNotification();

            // Draw FPS counter in the top-right corner
            drawFpsCounter();
        }

        function gameOver() {
            gameRunning = false;
            // Save high score when game ends
            saveHighScore();
            gameHUD.showGameOver(`You survived ${wave} waves and killed ${zombiesKilled} zombies!\nHigh Score: ${highScore} zombies`);
        }

        function restartGame() {
            // Play restart confirmation sound
            playRestartSound();
            
            // Return to main menu instead of restarting immediately
            showMainMenu = true;
            gameRunning = false;
            gamePaused = false;
            gameHUD.hidePauseMenu(); // Hide pause menu
            gameHUD.hideGameOver(); // Hide game over screen
            
            // Reset game state
            score = 0;
            wave = 1;
            zombiesKilled = 0;
            zombiesPerWave = 5;
            isSpawningWave = false;
            player.health = PLAYER_MAX_HEALTH;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            bullets = [];
            zombies = [];
            particles = [];
            healthPickups = [];
            ammoPickups = [];
            grenades = [];
            grenadeCount = MAX_GRENADES; // Reset grenades
            // Clear any pending zombie spawn timeouts
            zombieSpawnTimeouts.forEach(timeout => clearTimeout(timeout));
            zombieSpawnTimeouts = [];
            lastHealthPickupSpawnTime = Date.now();
            lastAmmoPickupSpawnTime = Date.now();
            currentAmmo = 10;
            maxAmmo = 10;
            muzzleFlash.active = false;
            waveNotification.active = false;
        }
        
        function playRestartSound() {
            // Play a restart confirmation sound
            if (!audioContext) {
                initAudio();
                if (!audioContext) return;
            }
            
            try {
                // Create a rising tone for restart confirmation
                const duration = 0.3; // 300ms
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);
                
                // Generate rising tone waveform
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / sampleRate;
                    // Rising frequency from 200Hz to 800Hz
                    const freq = 200 + (t / duration) * 600;
                    let sample = Math.sin(t * freq * 2 * Math.PI);
                    // Add some harmonics for richness
                    sample += Math.sin(t * freq * 2 * 2 * Math.PI) * 0.3;
                    sample += Math.sin(t * freq * 3 * 2 * Math.PI) * 0.1;
                    // Envelope: medium attack, medium decay
                    const attack = Math.min(1, t / 0.05); // 50ms attack
                    const decay = Math.max(0, 1 - (t - 0.05) / (duration - 0.05));
                    const envelope = attack * decay;
                    data[i] = sample * envelope * 0.2; // Volume
                }
                
                // Play the sound
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0.3; // Volume level
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(0);
            } catch (error) {
                // Silently fail if audio can't play
            }
        }

        function gameLoop() {
            // Basic FPS calculation (smoothed over ~0.5s)
            const now = performance.now();
            framesSinceFpsUpdate++;
            if (now - lastFpsUpdateTime >= 500) { // update roughly twice a second
                fps = Math.round((framesSinceFpsUpdate * 1000) / (now - lastFpsUpdateTime));
                framesSinceFpsUpdate = 0;
                lastFpsUpdateTime = now;
            }

            // Only update game if not showing main menu
            if (!showMainMenu && !gamePaused) {
                updateGame();
            }
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        // Initialize game (but don't start until menu is dismissed)
        loadHighScore(); // Load high score on game start
        initGrassPattern(); // Initialize grass pattern
        canvas.style.cursor = 'default'; // Show cursor initially for menu
        
        // Function to start the game (called from menu)
        function startGame() {
            // Ensure clean initial state
            gameRunning = true;
            gamePaused = false;
            score = 0;
            wave = 1;
            zombiesKilled = 0;
            zombiesPerWave = 5;
            isSpawningWave = false;
            zombies = [];
            zombieSpawnTimeouts = [];
            bullets = [];
            particles = [];
            healthPickups = [];
            ammoPickups = [];
            grenades = [];
            grenadeCount = 3; // Start with 3 grenades
            lastAmmoPickupSpawnTime = Date.now();
            waveNotification.active = false;
            currentAmmo = currentWeapon.ammo;
            maxAmmo = currentWeapon.maxAmmo;
            isReloading = false;
            // Trigger wave notification for Wave 1
            triggerWaveNotification();
            spawnZombies(zombiesPerWave);
        }
        
        // Start game loop (menu will be shown first)
        gameLoop();
    </script>
</body>
</html>
